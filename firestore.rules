rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isSignedIn() {
      // Allow any authenticated user, including anonymous
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    function isServiceAccount() {
      return request.auth.token.email != null && 
        request.auth.token.email.matches('.*@[a-zA-Z0-9-]+\\.iam\\.gserviceaccount\\.com$');
    }

    function isValidUserData() {
      let validFields = [
        'email', 'name', 'isOnline', 'lastLogin', 'lastUpdated',
        'notificationPreferences', 'favoriteTemplates', 'likedTemplates'
      ];
      return request.resource.data.keys().hasOnly(validFields);
    }

    function isValidTemplateData() {
      let allowedFields = ['likeCount', 'favoriteCount', 'lastUpdated'];
      return request.resource.data.keys().hasAll(['likeCount', 'favoriteCount', 'lastUpdated'])
        && request.resource.data.keys().hasOnly(allowedFields);
    }

    function isValidTemplateUpdate() {
      let allowedFields = ['likeCount', 'favoriteCount', 'lastUpdated'];
      let diff = request.resource.data.diff(resource.data);
      return diff.changedKeys().hasOnly(allowedFields);
    }

    // User document rules
    match /users/{userId} {
      // Users can read/write their own data
      allow read: if isSignedIn();
      allow write: if isOwner(userId);
      
      // Allow create with any authentication
      allow create: if isSignedIn() && request.auth.uid == userId && isValidUserData();
      
      // Allow update if owner and valid data
      allow update: if isOwner(userId) && isValidUserData();
      
      // Allow delete only by owner
      allow delete: if isOwner(userId);

      // User preferences subcollection
      match /preferences/{prefId} {
        allow read, write: if isOwner(userId);
      }

      // Likes subcollection
      match /likes/{templateId} {
        allow read: if isSignedIn();
        allow write: if isOwner(userId);
      }
      
      // Favorites subcollection
      match /favorites/{templateId} {
        allow read: if isSignedIn();
        allow write: if isOwner(userId);
      }

      // Notifications subcollection
      match /notifications/{notificationId} {
        allow read: if isOwner(userId);
        allow create, update, delete: if isOwner(userId);
      }
    }

    // Templates collection - Allow read/write for authenticated users
    match /templates/{templateId} {
      allow read: if true;
      
      // Allow creation and updates for authenticated users
      allow create: if isSignedIn();
      
      // Allow updates to like/favorite counts for authenticated users
      allow update: if isSignedIn() && 
        request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['likeCount', 'favoriteCount', 'lastUpdated', 'id', 'name', 'imageUrl']);
      
      // Allow any write operation with merge option (set with merge)
      allow write: if isSignedIn();
    }

    // User likes collection
    match /user_likes/{likeId} {
      allow read: if isSignedIn();
      allow create, delete: if isSignedIn() && 
        request.auth.uid == likeId.split('_')[0];
    }

    // User favorites collection
    match /user_favorites/{favoriteId} {
      allow read: if isSignedIn();
      allow create, delete: if isSignedIn() && 
        request.auth.uid == favoriteId.split('_')[0];
    }
    
    // Analytics collection for error tracking
    match /analytics/{docId} {
      allow create: if isSignedIn();
      allow read: if isServiceAccount();
    }
    
    // Special rule for collection group queries
    // This allows querying all likes and favorites across users
    match /{path=**}/likes/{documentId} {
      allow read: if isSignedIn();
    }
    
    match /{path=**}/favorites/{documentId} {
      allow read: if isSignedIn();
    }
  }
} 