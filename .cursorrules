# Instructions

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again. 

You should also use the `.cursorrules` file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

# Tools

Note all the tools are in python. So in the case you need to do batch processing, you can always consult the python files and write your own script.

## Screenshot Verification

The screenshot verification workflow allows you to capture screenshots of web pages and verify their appearance using LLMs. The following tools are available:

1. Screenshot Capture:
```bash
venv/bin/python tools/screenshot_utils.py URL [--output OUTPUT] [--width WIDTH] [--height HEIGHT]
```

2. LLM Verification with Images:
```bash
venv/bin/python tools/llm_api.py --prompt "Your verification question" --provider {openai|anthropic} --image path/to/screenshot.png
```

Example workflow:
```python
from screenshot_utils import take_screenshot_sync
from llm_api import query_llm

# Take a screenshot

screenshot_path = take_screenshot_sync('https://example.com', 'screenshot.png')

# Verify with LLM

response = query_llm(
    "What is the background color and title of this webpage?",
    provider="openai",  # or "anthropic"
    image_path=screenshot_path
)
print(response)
```

## LLM

You always have an LLM at your side to help you with the task. For simple tasks, you could invoke the LLM by running the following command:
```
venv/bin/python ./tools/llm_api.py --prompt "What is the capital of France?" --provider "anthropic"
```

The LLM API supports multiple providers:
- OpenAI (default, model: gpt-4o)
- Azure OpenAI (model: configured via AZURE_OPENAI_MODEL_DEPLOYMENT in .env file, defaults to gpt-4o-ms)
- DeepSeek (model: deepseek-chat)
- Anthropic (model: claude-3-sonnet-20240229)
- Gemini (model: gemini-pro)
- Local LLM (model: Qwen/Qwen2.5-32B-Instruct-AWQ)

But usually it's a better idea to check the content of the file and use the APIs in the `tools/llm_api.py` file to invoke the LLM if needed.

## Web browser

You could use the `tools/web_scraper.py` file to scrape the web.
```
venv/bin/python ./tools/web_scraper.py --max-concurrent 3 URL1 URL2 URL3
```
This will output the content of the web pages.

## Search engine

You could use the `tools/search_engine.py` file to search the web.
```
venv/bin/python ./tools/search_engine.py "your search keywords"
```
This will output the search results in the following format:
```
URL: https://example.com
Title: This is the title of the search result
Snippet: This is a snippet of the search result
```
If needed, you can further use the `web_scraper.py` file to scrape the web page content.

# Lessons

## User Specified Lessons

- You have a python venv in ./venv. Use it.
- Include info useful for debugging in the program output.
- Read the file before you try to edit it.
- Due to Cursor's limit, when you use `git` and `gh` and need to submit a multiline commit message, first write the message in a file, and then use `git commit -F <filename>` or similar command to commit. And then remove the file. Include "[Cursor] " in the commit message and PR title.

## Cursor learned

- For search results, ensure proper handling of different character encodings (UTF-8) for international queries
- Add debug information to stderr while keeping the main output clean in stdout for better pipeline integration
- When using seaborn styles in matplotlib, use 'seaborn-v0_8' instead of 'seaborn' as the style name due to recent seaborn version changes
- Use 'gpt-4o' as the model name for OpenAI's GPT-4 with vision capabilities
- When searching for recent news, use the current year (2025) instead of previous years, or simply use the "recent" keyword to get the latest information
- When implementing singleton classes in Android, ensure proper initialization before use:
  - Add an explicit init() method that takes a Context parameter
  - Check for null context and use applicationContext to prevent memory leaks
  - Add proper error handling with clear error messages
  - Implement thread-safe getInstance() method with synchronized keyword
  - Add initialization checks before returning instances
  - Use proper logging for debugging initialization issues
- When managing dependencies between singleton classes in Android:
  - Be aware of initialization order between singletons that depend on each other
  - Always initialize security/authentication managers before network/API clients
  - Use a hierarchical initialization approach, starting with core services first
  - Add null checks and proper error handling for dependent services
  - Make service fields non-final if initialization can fail or happen asynchronously
  - Add fallback mechanisms in case dependent services fail to initialize
  - Consider service registration patterns for complex dependency graphs
- When working with LiveData in Android:
  - Always use postValue() instead of setValue() when updating LiveData from background threads
  - LiveData.setValue() can only be called from the main thread, otherwise it throws IllegalStateException
  - Use proper threading practices: AppExecutors or Handlers for background operations
  - Consider using observeForever() with proper cleanup for background workers that need LiveData updates
  - Add thread safety checks before LiveData operations in repository classes
  - Be cautious when initializing repositories with LiveData in Application.onCreate()
  - Use SingleLiveEvent for one-time events to avoid LiveData redelivery on configuration changes
- When working with Room database in Android:
  - Add @Ignore annotation to additional constructors to avoid Room warnings
  - Ensure field names in DAO queries match the actual entity field names
  - Use appropriate return types in DAO methods (LiveData<T> vs T)
  - Implement proper type converters for complex types
  - Add proper error handling for database operations
  - When storing complex objects, ensure proper type checking and casting when retrieving data
  - Handle type conversion between Object and specific types like JsonObject with proper instanceof checks
- When implementing Gson converters for Retrofit:
  - Create custom JsonDeserializer for handling complex JSON structures
  - Register type adapters with GsonBuilder for specific types
  - Handle edge cases like null values and different JSON types
  - Use proper error handling for deserialization exceptions
- When working with generic types in Java:
  - Be careful with type inference when using generic methods
  - Use explicit type parameters when inference fails
  - Add proper type checking and casting when working with Object types
  - Handle type conversion between Object and specific types with proper instanceof checks
- When handling JSON data in Android with Gson:
  - Be aware that Gson deserializes JSON objects to LinkedTreeMap by default
  - Always use proper type checking with instanceof before casting
  - Implement conversion methods between LinkedTreeMap and JsonObject
  - Use JsonParser.parseString(json).getAsJsonObject() instead of gson.fromJson() for more reliable conversion
  - Add try-catch blocks around JSON parsing operations to handle malformed data
  - Consider updating entity data with properly converted objects for future use
- When working with Java/Android type comparisons:
  - Always match types in comparisons (don't compare String with int)
  - Use proper type checking before comparing: entity.getId() != null && !entity.getId().isEmpty() instead of entity.getId() > 0
  - Check for null and empty string separately when working with String IDs
  - Add explicit type conversions if comparison between different types is needed (Integer.parseInt())
- When working with lambda expressions in Java:
  - Variables captured in lambda expressions must be final or effectively final
  - Create final copies of variables before passing them to lambdas: final CoinsEntity finalEntity = entity
  - Be careful with mutating captured objects within lambdas
  - Use effectively final variables whenever possible to avoid creating extra copies
- When implementing Android string resources:
  - Always define error messages and other UI text in strings.xml 
  - Use consistent naming convention for string resources
  - Group related strings together with XML comments
  - Add string resources before referencing them in code to avoid R.string not found errors
- When implementing server-side AdMob integration:
  - Use a centralized service for managing ad configurations
  - Implement caching to reduce database load and improve response times
  - Add proper error handling and logging for all ad-related operations
  - Secure ad-related endpoints with authentication middleware
  - Implement rate limiting to prevent abuse
  - Create a lightweight client library for minimal client-side processing
  - Add offline support with local storage for ad configurations
  - Track impressions and clicks server-side for better analytics
  - Implement analytics service for tracking ad performance metrics
  - Set up monitoring service for real-time tracking of ad operations
  - Add alerting for critical issues in the monitoring service
  - Create comprehensive documentation for the integration
  - Implement comprehensive testing for all components
  - Use in-memory MongoDB for testing database operations
  - Mock external dependencies for isolated testing
  - Test edge cases like rate limiting and cache expiration
  - Implement integration tests for authentication middleware
  - Test analytics tracking and monitoring functionality
- When working with Express middleware:
  - Ensure consistent naming of middleware functions across all route files
  - Verify that imported middleware function names match the exported names from the middleware file
  - Use descriptive names that clearly indicate the middleware's purpose (e.g., verifyApiKey, validateRequest)
  - When refactoring middleware, update all route files that use the middleware
  - Consider using middleware factories for configurable middleware
  - Add proper error handling in middleware functions
  - Use next() to pass control to the next middleware in the chain
  - Document middleware functions with JSDoc comments
- When implementing Firebase Phone Authentication:
  - Add proper exception handling for FirebaseException in callbacks
  - Ensure variables used in lambda expressions are final or effectively final
  - Use SecureTokenManager for storing sensitive authentication tokens
  - Create a separate UserRepository to manage user authentication state
  - Implement proper token refresh logic in API clients
  - Add debug logging for authentication processes
  - Consider creating a mock server for local testing without Firebase dependencies
  - Save test logs when running automated authentication tests
  - Use different API base URLs for debug and production environments
  - Provide comprehensive technical documentation for the authentication system
- When configuring OkHttp client for Android applications:
  - Use connection pooling to improve connection reuse
  - Enable retryOnConnectionFailure for intermittent network issues
  - Add HTTP response caching to reduce network requests
  - Log detailed connection information in debug builds
  - Set appropriate timeouts for different network conditions
  - Track timing metrics for API calls to identify performance issues
  - Add detailed error logging for failed requests
  - Use interceptors to add common headers across all requests
- When removing AdMob integration from an Android application:
  - Delete all ad-related classes and files (AdMobManager, AdConfig, etc.)
  - Remove Firebase dependencies from build.gradle
  - Update SecureTokenManager and DeviceUtils to maintain API compatibility
  - Remove AdMob-related endpoints from ApiService
  - Keep API key handling methods even after removing ad functionality
  - Clean up imports and initialization code in Application class
  - Remove AdMob-related references from Room database entities and DAOs
  - Modify UI fragments and activities to remove ad containers and references
  - Run clean builds frequently to catch missing files and dependencies
  - Fix possible dependency issues by downgrading to compatible versions like OkHttp 4.9.0 instead of 4.12.0
- When implementing Express.js API routes in a Node.js backend:
  - Always properly register route modules in the main server.js or app.js file
  - Use app.use('/api/endpoint', require('./routes/endpoint')) pattern
  - Check for 404 errors in API responses which often indicate missing route registration
  - Ensure route paths in the router match the client-side API calls
  - Add explicit route prefixes in app.use() that match client expectations
  - Validate that middleware is properly imported and applied to routes
  - Add error logging for failed API requests to quickly identify issues
  - Use consistent error response formats across all API endpoints

# Scratchpad

## Current Task: Personalized Template Recommendations

### Problem Statement
Now that we're tracking user interactions with categories (both direct category clicks and template selections), we need to implement a personalized recommendation system that prioritizes templates from categories the user interacts with most frequently. 

### Data Foundation
The enhanced `User` model now includes:
- Category tracking of both direct category clicks and template selections
- Visit counts for each category 
- Source tracking to differentiate between direct category navigation and template-based interactions
- Recency information through visitDate timestamps

### Action Plan
[X] 1. Create a recommendation scoring algorithm:
   - Develop a weighted scoring system that prioritizes:
     - Categories with higher visitCount
     - Recent category interactions (newer visitDate)
     - Categories visited through templates (potentially higher interest signal)
   - Create API endpoint to fetch top categories for a user
   - Implement sorting logic for template prioritization

[X] 2. Backend implementation:
   - Enhance the existing recommendations endpoint to include scoring
   - Create a service that fetches templates based on top user categories
   - Implement caching for recommendation results
   - Add pagination for recommendation results
   - Create a fallback recommendation strategy for new users

[X] 3. Frontend implementation:
   - Create a PersonalizedTemplatesFragment/adapter for the recommended templates
   - Add a new section in HomeFragment for personalized recommendations
   - Implement UI for displaying recommendations with section header
   - Add visual indicators for recommended items
   - Implement smooth loading states and transitions

[ ] 4. Analytics and improvement:
   - Track recommendation engagement metrics
   - Implement A/B testing framework for algorithm improvements
   - Add feedback mechanism for recommendations
   - Create analytics dashboard for recommendation performance

### Implementation Status

#### 1. Backend Components (Complete)
[X] Created recommendation service with the following features:
   - Implemented category scoring algorithm that weighs:
     - Visit count (50% weight)
     - Recency (30% weight)
     - Interaction type (20% for template views, 10% for direct category visits)
   - Added caching with a 30-minute TTL for performance
   - Implemented template diversity algorithm that interleaves results from different categories
   - Created fallback recommendations for new users
   - Added cache invalidation when users interact with categories or templates

[X] Enhanced API endpoints:
   - Updated `/api/users/:deviceId/recommendations` endpoint to use the recommendation service
   - Added limit parameter for pagination
   - Added cache invalidation in activity and template-view endpoints

#### 2. Frontend Components (Complete)
[X] Added HomeViewModel support for recommendations:
   - Added methods to fetch personalized recommendations
   - Created LiveData objects to hold recommendation results
   - Added proper error handling and loading states

[X] Updated HomeFragment UI:
   - Added "Recommended For You" section
   - Implemented RecyclerView adapter for recommendations
   - Added loading states with shimmer effect
   - Created smooth transitions between sections
   - Fixed method naming for consistency

[X] Enhanced template interaction tracking:
   - Added onTemplateClick method to track template views
   - Created recordTemplateView and trackTemplateView methods in UserRepository
   - Added proper API endpoint for template view tracking
   - Added refresh logic for recommendations when returning to HomeFragment

#### 3. Client-Side Category Tracking (Complete)
[X] Enhanced user tracking to include template interactions:
   - Modified `UserRepository` to track template views with categories
   - Updated `onTemplateClick` handlers to record template views
   - Added rate limiting to prevent excessive API calls

### Next Steps
1. Test the recommendation flow with real user data
2. Add analytics tracking to measure effectiveness
3. Optimize the algorithm based on user feedback
4. Implement A/B testing framework for continuous improvement

### Recommendation Algorithm Details

#### Category Score Calculation
Each category receives a score based on:
1. **Interaction Count**: The number of times a user has interacted with a category
   ```
   countScore = visitCount / maxVisitCount * 50
   ```

2. **Recency**: How recently the user interacted with the category
   ```
   recencyScore = (currentTime - visitDate) / maxTimeDiff * 30
   ```

3. **Interaction Type**: Direct category visits vs. template-based interactions
   ```
   sourceScore = (source == 'template') ? 20 : 10
   ```

4. **Total Score**: Sum of the above components
   ```
   totalScore = countScore + recencyScore + sourceScore
   ```

#### Template Selection Process (Implemented)
1. Select top 2-3 categories based on score
2. From each category, select newest and most popular templates
3. Interleave results to ensure diversity
4. Return up to requested limit (default 10)
5. Cache results for 30 minutes for performance

### Expected Outcomes
1. Users will discover more relevant templates faster
2. Engagement with the app will increase (longer sessions, more customizations)
3. User satisfaction will improve with more personalized content
4. App will feel more tailored to individual needs
5. Analytics will provide insights for further improvements

## Previous Task: Background User Registration Feature

### Problem Statement
The app needs to implement automatic background user registration with the server when a user first opens the app. The key requirements are:
1. Register new users with their device ID as a unique identifier
2. Track when users were last online
3. Record user activity history, specifically which categories they visit
4. Implementation should be done server-side in the existing backend

### Data Model
For the `users` collection/table:
```
{
  deviceId: String,          // Unique identifier from the device
  lastOnline: Date,          // Timestamp of last activity
  created: Date,             // When user was first registered
  categories: [              // Array of category visit history
    {
      category: String,      // Category name/ID
      visitDate: Date        // When the category was visited
    }
  ]
}
```

### Action Plan
[X] 1. Server-side implementation:
   - Create a User model schema in the backend
   - Implement API endpoints for user registration and activity tracking
   - Set up proper validation and error handling
   - Implement device ID verification

[X] 2. Client-side implementation:
   - Add background registration when app is first opened
   - Implement background category visit tracking
   - Set up periodic last online updates
   - Handle network errors gracefully

[X] 3. Fix implementation issues:
   - Change LiveData's setValue() to postValue() in background threads
   - Add better initialization checks and retry mechanism in EventWishApplication
   - Register the user routes in server.js to make API endpoints accessible
   - Improve error handling for network failures

### Implementation Details

#### 1. Server-side (Backend):
[X] Create User model schema (models/User.js):
   - Defined schema with deviceId, lastOnline, created, and categories fields
   - Added indexes for efficient querying
   - Implemented validation for incoming data
   - Added helper methods for updating lastOnline and category visits

[X] Create API routes (routes/users.js):
   - POST /api/users/register - Register new user with device ID
   - PUT /api/users/activity - Update user's last online and category visits
   - GET /api/users/:deviceId - Get user data (for testing)
   - Added proper error handling and validation

[X] Implement middleware:
   - Created validators.js middleware for input validation
   - Added validation for device IDs and category names
   - Implementation includes input sanitization and format checking

[X] Update server.js:
   - Added the new user routes to app.js
   - Set up logger utility for proper logging
   - Fixed missing route registration in server.js

#### 2. Client-side (Android App):
[X] Generate and store unique device ID:
   - Created UserRepository with device ID generation and storage
   - Used Android ID with fallback to UUID generation
   - Added SHA-256 hashing for privacy protection
   - Store securely in SharedPreferences

[X] Implement background registration:
   - Added user registration in EventWishApplication.onCreate
   - Implemented API endpoints in ApiService
   - Added error handling and retry logic
   - Created asynchronous registration using Executor
   - Fixed LiveData threading issue by using postValue() instead of setValue()

[X] Track category visits:
   - Updated HomeFragment to send category visit data
   - Implemented tracking in category selection click handler
   - Added special handling for "All" category
   - Rate limiting to prevent too frequent updates (5 minute interval)

[X] Update last online status:
   - Implemented period updates in onActivityResumed
   - Added throttling to prevent excessive API calls
   - Proper error handling for network failures

### Completion Notes
The background user registration feature has been successfully implemented with all issues fixed:

1. **Server-side components** provide a robust system for tracking user activity:
   - The `User` model with proper schema and validation
   - Complete API endpoints with proper error handling
   - Input validation middleware to ensure data integrity
   - Logging for debugging and monitoring
   - Routes properly registered in server.js to make endpoints accessible

2. **Client-side implementation** handles automatic registration and tracking:
   - Secure device ID generation with privacy protections
   - Background registration when the app first starts
   - Tracking of category visits when users browse different categories
   - Automatic updates of online status as users use the app
   - Rate limiting to prevent server overload
   - Fixed LiveData threading issues by using postValue() instead of setValue()
   - Added better initialization checks and retry mechanisms

3. **Key fixes applied**:
   - Fixed 404 error by registering the user routes in server.js
   - Fixed IllegalStateException by using postValue() instead of setValue() on background threads
   - Added proper initialization checks and error handling in EventWishApplication
   - Implemented retries for critical operations
   - Used AppExecutors for better thread management

These changes enable valuable analytics capabilities while maintaining user privacy. The system is designed to be lightweight and unobtrusive, with minimal impact on app performance. The collected data can be used for future personalization features, allowing the app to recommend templates based on users' browsing patterns.

## Previous Task: Improve UI/UX Elements

### Problem Statement
Three UI/UX issues need to be addressed to improve the user experience:
1. Swipe refresh loader is not showing when app is first opened, giving no indication that data is being fetched
2. When a category is selected, there's no visual indication (highlighting) to show which category is active
3. When users press the back button to exit the app from the HomeFragment, there's no confirmation, which can lead to accidental exits

### Action Plan
[X] 1. Fix swipe refresh loader visibility:
   - Modify HomeFragment to show the swipe refresh indicator when the app first loads data
   - Ensure the indicator is properly shown during initial data fetch and disappears when complete
   - Add proper coordination between loading states and the SwipeRefreshLayout

[X] 2. Implement category selection highlighting:
   - Enhance the CategoriesAdapter to properly highlight the selected category
   - Add visual styling for the active category (background color, text color change, etc.)
   - Ensure the highlighting persists when navigating back to HomeFragment
   - Update the category item layout to support highlighting states
   - Fixed "All" category not highlighting properly with improved null handling logic

[X] 3. Add back button exit confirmation:
   - Implement double-back-press detection in HomeFragment
   - Add a toast message notifying users to "Press back again to exit"
   - Set up a timer to reset the back press state after a short delay
   - Handle the back button press through the OnBackPressedCallback interface

### Implementation Details
1. **Swipe Refresh Loader**:
   - Update HomeFragment.onViewCreated to trigger SwipeRefreshLayout.setRefreshing(true) during initial load
   - Improved loading state observer to coordinate with the SwipeRefreshLayout indicator
   - Added a small delay before hiding the refresh indicator for better visibility

2. **Category Selection Highlighting**:
   - Added a selectedCategoryId field to CategoriesAdapter to track the selected category
   - Updated onBindViewHolder to apply different styling for selected items (colors for text and icon)
   - Using the existing bg_category_selector drawable that already had selected state styling
   - Improved updateSelectedCategory method to check for unchanged selections for better performance
   - Fixed "All" category highlighting by improving the null-handling logic in isSelected calculation
   - Made the selection logic more explicit with separate conditions for null (All category) and non-null cases

3. **Back Button Exit Confirmation**:
   - Added backPressedTime variable and BACK_PRESS_DELAY constant for tracking double-press timing
   - Implemented setupBackPressHandling() with OnBackPressedCallback to handle back button presses
   - Added toast message with "Press back again to exit" on first press
   - Added a string resource for the exit message
   - Implemented app exit on second press if within the time window (2 seconds)

### Completion Notes
All three UI/UX issues have been successfully addressed:
1. The swipe refresh loader now provides proper visual feedback during initial data loading
2. Categories are now visually highlighted when selected, with color changes to both text and icons, including special handling for the "All" category 
3. Users now get a clear confirmation message when attempting to exit the app, preventing accidental exits

These improvements collectively enhance the user experience by providing better visual feedback and navigation controls.

## Previous Task: Fix UI Flow and Navigation Issues

### Problem Statement
Three specific issues in the app's UI flow and navigation needed to be addressed:
1. When navigating from TemplateCustomizeFragment back to HomeFragment, data is unnecessarily reloaded
2. When the app is first opened, only default category icons are shown until a manual refresh
3. Clicking on the profile bottom navigation item doesn't navigate correctly

### Action Plan
[X] 1. Fix HomeFragment data state persistence:
   - Modify onResume to avoid full data reloading when coming from another fragment
   - Add isNavigatingToAnotherFragment helper to distinguish between background transitions and in-app navigation
   - Save and restore scroll position when returning from other fragments

[X] 2. Fix category icons loading:
   - Force refresh category icons when HomeFragment is first created
   - Explicitly load categories immediately when setting up the categories RecyclerView
   - Ensure both default and dynamic category icons are available on first load

[X] 3. Fix profile navigation:
   - Add special handling for profile navigation in MainActivity's setupNavigation method
   - Directly navigate to the profile fragment when the profile menu item is clicked
   - Log navigation events for easier debugging

### Implementation Notes
The key issues were:

1. **Fragment Navigation State**:
   - The app was treating navigation between fragments the same as coming back from background
   - This caused unnecessary API calls and data reloading
   - Fixed by adding better state tracking to distinguish between different navigation types

2. **Category Icons Loading**:
   - CategoryIconRepository was only loading default icons initially
   - Dynamic icons were only fetched when manually refreshed
   - Fixed by forcing an immediate refresh when the fragment is first created

3. **Bottom Navigation**:
   - Profile tab navigation was relying on standard NavigationUI behavior which had issues
   - Fixed by adding special handling similar to how home navigation was handled
   - Now explicitly navigates to profile destination when the tab is selected

### Completion Notes
All three issues have been successfully fixed:
1. HomeFragment now maintains its data state when navigating between fragments
2. Category icons are properly loaded on first app launch without requiring manual refresh
3. Profile navigation works correctly when clicking the profile tab in the bottom navigation

The build completed successfully with no errors, indicating that all changes integrate well with the existing codebase.